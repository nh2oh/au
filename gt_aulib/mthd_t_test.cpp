#include "gtest/gtest.h"
#include "..\aulib\input\midi\mthd_t.h"
#include <vector>
#include <array>
#include <cstdint>



//
// Tests for:
// maybe_mthd_t make_mthd(const unsigned char *end, const unsigned char *end);
//
// With invalid input data
//
TEST(mthd_tests, MakeMthdInvalidInput) {
	struct test_t {
		std::array<unsigned char,14> data;
		uint32_t offset_to_data_end {0};
	};
	std::vector<test_t> tests_invalid {
		// range < 14
		{{0x4D,0x54,0x68,0x64,0x00,0x00,0x00,0x06,0x00,0x01,0x00,0x03,0x00,0xF0},13},
		{{0x4D,0x54,0x68,0x64,0x00,0x00,0x00,0x06,0x00,0x01,0x00,0x03,0x00,0xF0},0},
		// Range < 14, but consistent w/ length field
		{{0x4D,0x54,0x68,0x64,0x00,0x00,0x00,0x05,0x00,0x01,0x00,0x03,0x00,0xF0},13},
		{{0x4D,0x54,0x68,0x64,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x03,0x00,0xF0},9},
		{{0x4D,0x54,0x68,0x64,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x03,0x00,0xF0},8},
		// length field is < 6; range is ok
		{{0x4D,0x54,0x68,0x64,0x00,0x00,0x00,0x05,0x00,0x01,0x00,0x03,0x00,0xF0},14},
		{{0x4D,0x54,0x68,0x64,0x00,0x00,0x00,0x04,0x00,0x01,0x00,0x03,0x00,0xF0},14},

		// format==0 but ntrks > 1
		{{0x4D,0x54,0x68,0x64,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0x02,0x00,0xF0},100},
		{{0x4D,0x54,0x68,0x64,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0x03,0x00,0xF0},100},

		// Invalid SMPTE
		{{0x4D,0x54,0x68,0x64,0x00,0x00,0x00,0x06,0x00,0x01,0x00,0x02,0xFF,0xFF},100},
		{{0x4D,0x54,0x68,0x64,0x00,0x00,0x00,0x06,0x00,0x02,0x00,0x02,0x80,0x00},100}
	};
	
	for (const auto& tcase : tests_invalid) {
		auto beg = tcase.data.data();
		auto end = beg + tcase.offset_to_data_end;
		auto mthd = make_mthd(beg,end);
		
		EXPECT_FALSE(mthd);
	}
}

//
// Tests for:
// maybe_mthd_t make_mthd(const unsigned char *end, const unsigned char *end);
//
// With valid input data
//
TEST(mthd_tests, MakeMthdValidInput) {
	struct test_t {
		std::array<unsigned char,14> data;
		uint32_t offset_to_data_end {0};
	};

	std::vector<test_t> tests_valid {
		// Varying values for length, but always within input range
		{{0x4D,0x54,0x68,0x64,0x00,0x00,0x00,0x06,0x00,0x01,0x00,0x03,0x00,0xF0},14},
		{{0x4D,0x54,0x68,0x64,0x00,0x00,0x00,0x06,0x00,0x01,0x00,0x03,0x00,0xF0},100},
		// length == 15, range == 25 (==15+8)
		{{0x4D,0x54,0x68,0x64,0x00,0x00,0x00,0x0F,0x00,0x01,0x00,0x03,0x00,0xF0},23},
		// Varying format, ntrks.  ntrks == 0 is valid for all formats
		// ntrks == 0
		{{0x4D,0x54,0x68,0x64,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0x00,0x00,0xF0},100},
		{{0x4D,0x54,0x68,0x64,0x00,0x00,0x00,0x06,0x00,0x01,0x00,0x00,0x00,0xF0},100},
		{{0x4D,0x54,0x68,0x64,0x00,0x00,0x00,0x06,0x00,0x02,0x00,0x00,0x00,0xF0},100},
		// ntrks == 1
		{{0x4D,0x54,0x68,0x64,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0x01,0x00,0xF0},100},
		{{0x4D,0x54,0x68,0x64,0x00,0x00,0x00,0x06,0x00,0x01,0x00,0x01,0x00,0xF0},100},
		{{0x4D,0x54,0x68,0x64,0x00,0x00,0x00,0x06,0x00,0x02,0x00,0x01,0x00,0xF0},100},
		// ntrks == 2, except for format == 0
		{{0x4D,0x54,0x68,0x64,0x00,0x00,0x00,0x06,0x00,0x01,0x00,0x02,0x00,0xF0},100},
		{{0x4D,0x54,0x68,0x64,0x00,0x00,0x00,0x06,0x00,0x02,0x00,0x02,0x00,0xF0},100},
		// ntrks == max
		{{0x4D,0x54,0x68,0x64,0x00,0x00,0x00,0x06,0x00,0x01,0xFF,0xFF,0x00,0xF0},100},
		{{0x4D,0x54,0x68,0x64,0x00,0x00,0x00,0x06,0x00,0x02,0xFF,0xFF,0x00,0xF0},100},
		// Weird values for format
		{{0x4D,0x54,0x68,0x64,0x00,0x00,0x00,0x06,0x00,0x09,0x00,0x00,0x00,0xF0},100},
		{{0x4D,0x54,0x68,0x64,0x00,0x00,0x00,0x06,0x00,0x09,0x00,0x03,0x00,0xF0},100},
		{{0x4D,0x54,0x68,0x64,0x00,0x00,0x00,0x06,0xFF,0xFF,0x00,0x00,0x00,0xF0},100},
		{{0x4D,0x54,0x68,0x64,0x00,0x00,0x00,0x06,0xFF,0xFF,0x00,0x03,0x00,0xF0},100}
	};

	for (const auto& tcase : tests_valid) {
		auto beg = tcase.data.data();
		auto end = beg + tcase.offset_to_data_end;
		auto mthd = make_mthd(beg,end);
		EXPECT_TRUE(mthd);
	}
}

TEST(mthd_tests, defaultCtor) {
	std::vector<unsigned char> ans {
		0x4Du,0x54u,0x68u,0x64u, 0x00u,0x00u,0x00u,0x06u,
		0x00u,0x01u, 0x00u,0x00u, 0x00u,0x78u
	};
	auto mthd = mthd_t();
	EXPECT_EQ(mthd.size(), ans.size());
	EXPECT_EQ(mthd.nbytes(), ans.size());
	
	auto cit=mthd.cbegin();
	auto cend=mthd.cend();
	for (int i=0; i<mthd.size(); ++i) {
		EXPECT_NE(cit,cend);
		EXPECT_EQ(*cit++,ans[i]);
	}
	EXPECT_EQ(cit,cend);

	EXPECT_EQ(mthd.length(),6);
	time_division_t tdf_ans(0x0078u);
	EXPECT_EQ(mthd.division().raw_value(),tdf_ans.raw_value());
	EXPECT_EQ(mthd.format(),1);
	EXPECT_EQ(mthd.ntrks(),0);
}


// 
// From p.133 of the midi std
//
TEST(mthd_tests, interpretSMPTEField) {
	struct test_t {
		uint16_t input {0};
		int8_t ans_tcf {0};
		uint8_t ans_upf {0};
	};
	std::vector<test_t> tests {
		{0xE250u,-30,80},  // p.133 of the midi std
		{0xE728u,-25,40},   // 25fr/sec * 40tk/fr => 1000tk/sec => ms resolution
		{0xE350u,-29,80}
	};

	for (const auto& e : tests) {
		time_division_t curr_tdf(e.input);
		EXPECT_EQ(type(curr_tdf),time_division_t::type::smpte);

		auto curr_tcf = get_time_code_fmt(curr_tdf);
		EXPECT_EQ(curr_tcf,e.ans_tcf);
		auto curr_upf = get_units_per_frame(curr_tdf);
		EXPECT_EQ(curr_upf,e.ans_upf);
	}

}

