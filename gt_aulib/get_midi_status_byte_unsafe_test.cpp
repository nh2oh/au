#include "gtest/gtest.h"
#include "..\aulib\input\midi\midi_raw.h"
#include "midi_raw_test_data.h"
#include <vector>
#include <array>
#include <cstdint>



//
// Tests for:
// mtrk_event_get_midi_status_byte_unsafe(const unsigned char*, unsigned char=0u);
//
// Part 1:  running-status is a valid midi status byte.
//
// Sets of meta events, sysex_f0/f7 events, and midi events, paired with 
// "random" but valid running-status bytes.  Events also have dt fields of
// varying size.  For sysex and meta events, 0x00 should always be returned
// since these event types reset the running-status.  There are two sets of 
// midi events: set 1 are all valid w/ status byte 0x90u (=> each has 2 
// data bytes), set 2 are all valid w/ status byte 0xC0 (=> each has 1 data
// byte).  
//
//
TEST(get_midi_status_byte_unsafe, RandomMtrkEventsAllRSBytesValid) {
	for (const auto& e : set_a_valid_rs) {
		const unsigned char *p_dtstart = &(e.data[0]);
		auto s_dtstart = mtrk_event_get_midi_status_byte_dtstart_unsafe(p_dtstart, e.rs);
		EXPECT_EQ(s_dtstart,e.ans);

		const unsigned char *p = p_dtstart+e.dtsize;
		auto s = mtrk_event_get_midi_status_byte_unsafe(p, e.rs);
		EXPECT_EQ(s,e.ans);
	}
}


//
// Tests for:
// mtrk_event_get_midi_status_byte_unsafe(const unsigned char*, unsigned char=0u);
// and the _dtstart_ version.  
// Part 2:  running-status is an _invalid_ midi status byte.
//
// Sets of meta events, sysex_f0/f7 events, and midi events, paired with 
// "random" but *invalid* running-status bytes.  Events also have dt fields of
// varying size.  For sysex and meta events, 0x00 should always be returned
// since these event types reset the running-status.  There are two sets of 
// midi events: set 1 are all valid w/ status byte 0x90u (=> each has 2 
// data bytes), set 2 are all valid w/ status byte 0xC0 (=> each has 1 data
// byte).  Half of both sets have an event-local status byte, but the other
// half do not.  In the latter case, since all these examples contain invalid
// running-status bytes, are essentially "malformed," uninterpretible input;
// mtrk_event_get_midi_status_byte_unsafe() should return 0x00.  
//
TEST(get_midi_status_byte_unsafe, RandomMtrkEventsAllRSBytesInvalid) {
	for (const auto& e : set_b_invalid_rs) {
		const unsigned char *p_dtstart = &(e.data[0]);
		auto s_dtstart = mtrk_event_get_midi_status_byte_dtstart_unsafe(p_dtstart, e.rs);
		EXPECT_EQ(s_dtstart,e.ans);

		const unsigned char *p = p_dtstart+e.dtsize;
		auto s = mtrk_event_get_midi_status_byte_unsafe(p, e.rs);
		EXPECT_EQ(s,e.ans);
	}
}


//
// Tests for:
// mtrk_event_get_midi_status_byte_unsafe(const unsigned char*, unsigned char=0u)
//  and its _dtstart_ variant.  
//
// Part 3:  midi events only; running-status may or may not be valid, but all 
// composite events (data+rs byte) are valid and interpretible.  
//
// Set of midi events, paired with "random" but valid and invalid running-
// status bytes.  Those events paired w/ invalid rs bytes have a valid
// event-local status byte.  Events w/ valid rs bytes may or may not contain
// an event-local status byte; if not, the rs byte correctly describes the
// event.  Events also have dt fields of varying size.  
//
//
TEST(get_midi_status_byte_unsafe, RandomMIDIEventsRSandNonRS) {
	for (const auto& e : set_c_midi_events_valid) {
		const unsigned char *p_dtstart = &(e.data[0]);
		auto s_dtstart = mtrk_event_get_midi_status_byte_dtstart_unsafe(p_dtstart,e.midisb_prev_event);
		EXPECT_EQ(s_dtstart,e.applic_midi_status);

		const unsigned char *p = p_dtstart+e.dt_field_size;
		auto s = mtrk_event_get_midi_status_byte_unsafe(p,e.midisb_prev_event);
		EXPECT_EQ(s,e.applic_midi_status);
	}
}


//
// Tests for:
// mtrk_event_get_midi_status_byte_unsafe(const unsigned char*, unsigned char=0u)
//  and its _dtstart_ variant.  
//
// Part 4:  midi events only; running-status byte is in all cases invalid, yet 
// all events lack a local status byte.  These are essentially uninterpretible;
// expect to return 0x00u in all cases.  
// I have zeroed the fields is_rs, ndata, data_length; they are not used in the
// tests.  
//
TEST(get_midi_status_byte_unsafe, RandomMIDIEventsRSInvalidAndNoLocalStatusByte) {
	for (const auto& e : set_d_midi_events_nostatus_invalid) {
		const unsigned char *p_dtstart = &(e.data[0]);
		auto s_dtstart = mtrk_event_get_midi_status_byte_dtstart_unsafe(p_dtstart,e.midisb_prev_event);
		EXPECT_EQ(s_dtstart,e.applic_midi_status);

		const unsigned char *p = p_dtstart+e.dt_field_size;
		auto s = mtrk_event_get_midi_status_byte_unsafe(p,e.midisb_prev_event);
		EXPECT_EQ(s,e.applic_midi_status);
	}
}


/*
//
// Tests for:
// unsigned char mtrk_event_get_midi_status_byte_unsafe(const unsigned char*, unsigned char=0u);
// unsigned char mtrk_event_get_midi_status_byte_dtstart_unsafe(const unsigned char*, unsigned char=0u);
// uint32_t mtrk_event_get_size_dtstart_unsafe(const unsigned char*, unsigned char=0x00u);
//
// Random delta-time, random midi events, random running-status;  all events
// are valid.  Some have no event-local status-byte, in which case the running-
// status byte supplied in the test case accurately describes the number of
// data bytes in the message.  
//
// These functions also have expected behavior when fed meta and sysex messages,
// not tested here.  
TEST(midi_raw_tests, GetMIDIStatusByteMsgSizeUnsafeFuncsRandomMIDIMsgs) {
	struct test_t {
		std::vector<unsigned char> data {};
		unsigned char rs {0x00u};
		// "applicible [status byte]"
		// If the data field encodes a status byte, this is the value of that
		// event-local status byte.  If there is no event-local status byte,
		// this field has the same value as field rs.  In all cases where there
		// is no event-local status byte, the status byte in rs is valid and
		// correctly describes the number of data bytes in the message.  
		unsigned char applic_status {0x00u};
		uint8_t n_data_bytes {0};

		// Size of the message not including the delta-time field
		uint8_t data_length {0};  
	};

	std::vector<test_t> tests {
		{{0x64,0xDF,0x77},0xFF,0xDF,1,2},
		{{0x7F,0xD1,0x01},0xC1,0xD1,1,2},
		{{0x00,0x01,0x77},0x8F,0x8F,2,2},
		{{0x7F,0x9B,0x03,0x09},0x9F,0x9B,2,3},
		{{0xFF,0xFF,0xFF,0x7F,0xD1,0x10},0x9B,0xD1,1,2},
		{{0x81,0x00,0x90,0x03,0x10},0x81,0x90,2,3},
		{{0x40,0x09,0x03},0xB0,0xB0,2,2},
		{{0xFF,0xFF,0xFF,0x7F,0x90,0x03,0x77},0xD0,0x90,2,3},
		{{0x40,0x8F,0x00,0x0A},0x8F,0x8F,2,3},
		{{0xC0,0x00,0x77,0x00},0x90,0x90,2,2},
		{{0xC0,0x80,0x00,0xBF,0x10,0x10},0xB1,0xBF,2,3},
		{{0x40,0x70},0xC1,0xC1,1,1},
		{{0x81,0x80,0x80,0x00,0xDB,0x0F},0xFF,0xDB,1,2},
		{{0x81,0x80,0x80,0x00,0xCB,0x0A},0x81,0xCB,1,2},
		{{0x81,0x80,0x00,0x77,0x09},0xE0,0xE0,2,2},
		{{0x81,0x80,0x00,0xB0,0x10,0x09},0xBF,0xB0,2,3},
		{{0x00,0x0A},0xDF,0xDF,1,1},
		{{0xFF,0xFF,0xFF,0x7F,0x02,0x03},0xBF,0xBF,2,2},
		{{0x81,0x80,0x80,0x00,0xEB,0x02,0x70},0x91,0xEB,2,3},
		{{0x81,0x48,0x77,0x01},0xB1,0xB1,2,2},
		{{0xFF,0x7F,0x9F,0x0F,0x77},0x8F,0x9F,2,3},
		{{0xC0,0x00,0x9B,0x01,0x70},0xDF,0x9B,2,3},
		{{0x7F,0xE0,0x00,0x00},0xC1,0xE0,2,3},
		{{0xC0,0x00,0xEB,0x0A,0x09},0x80,0xEB,2,3},
		{{0x81,0x00,0x01,0x00},0x80,0x80,2,2},
		{{0x81,0x80,0x00,0x70,0x0A},0x90,0x90,2,2},
		{{0x00,0x00},0xCF,0xCF,1,1},
		{{0xC0,0x80,0x80,0x00,0x0A,0x03},0xB0,0xB0,2,2},
		{{0xFF,0xFF,0x7F,0x09},0xD1,0xD1,1,1},
		{{0xC0,0x80,0x80,0x00,0x77},0xCF,0xCF,1,1},
		{{0x40,0x0A,0x00},0x91,0x91,2,2},
		{{0xFF,0xFF,0x7F,0x02},0xCF,0xCF,1,1},
		{{0x40,0xBF,0x70,0x03},0xDB,0xBF,2,3},
		{{0xFF,0x7F,0x02},0xD1,0xD1,1,1},
		{{0xC0,0x80,0x80,0x00,0xD1,0x0F},0x8A,0xD1,1,2},
		{{0xC0,0x80,0x80,0x00,0x09},0xC1,0xC1,1,1},
		{{0x00,0x01},0xCB,0xCB,1,1},
		{{0x00,0x00,0x70},0x91,0x91,2,2},
		{{0x81,0x48,0x70},0xDF,0xDF,1,1},
		{{0xC0,0x80,0x00,0x0A,0x03},0x8A,0x8A,2,2},
		{{0x81,0x48,0xDB,0x0A},0xD1,0xDB,1,2},
		{{0x81,0x48,0x03},0xD0,0xD0,1,1},
		{{0xC0,0x00,0x10},0xC0,0xC0,1,1},
		{{0x40,0x9B,0x03,0x00},0x81,0x9B,2,3},
		{{0xC0,0x80,0x00,0xEF,0x02,0x01},0x8A,0xEF,2,3},
		{{0x64,0xE1,0x09,0x02},0x9F,0xE1,2,3},
		{{0xFF,0x7F,0x80,0x03,0x02},0xC0,0x80,2,3},
		{{0xC0,0x00,0x70,0x70},0x80,0x80,2,2},
		{{0x81,0x48,0x01},0xDF,0xDF,1,1},
		{{0x81,0x80,0x80,0x00,0x0F},0xDB,0xDB,1,1},
		{{0x81,0x00,0x02,0x09},0x9B,0x9B,2,2},
		{{0xFF,0x7F,0xBB,0x02,0x02},0xBF,0xBB,2,3},
		{{0xFF,0xFF,0x7F,0x00},0xC0,0xC0,1,1},
		{{0xC0,0x80,0x80,0x00,0x0F},0xD0,0xD0,1,1},
		{{0xC0,0x80,0x80,0x00,0xDB,0x03},0xC1,0xDB,1,2},
		{{0x81,0x00,0xDF,0x01},0xCF,0xDF,1,2},
		{{0x40,0x02,0x77},0xE1,0xE1,2,2},
		{{0xFF,0xFF,0x7F,0xCB,0x00},0xDB,0xCB,1,2},
		{{0x81,0x00,0xD1,0x0A},0x9B,0xD1,1,2},
		{{0xFF,0xFF,0x7F,0x0F,0x0F},0x8A,0x8A,2,2},
		{{0x81,0x80,0x00,0x10,0x02},0x8A,0x8A,2,2},
		{{0x00,0x77,0x77},0x91,0x91,2,2},
		{{0x40,0x80,0x09,0x02},0x80,0x80,2,3},
		{{0x64,0x0F,0x09},0xBB,0xBB,2,2},
		{{0xC0,0x80,0x80,0x00,0x01},0xCF,0xCF,1,1},
		{{0x81,0x80,0x00,0x0A,0x77},0x9F,0x9F,2,2},
		{{0x7F,0xBB,0x09,0x03},0x8F,0xBB,2,3},
		{{0x64,0x77},0xC0,0xC0,1,1},
		{{0xFF,0xFF,0xFF,0x7F,0xC0,0x03},0x90,0xC0,1,2},
		{{0xC0,0x80,0x00,0xEF,0x03,0x70},0x8F,0xEF,2,3},
		{{0x40,0x03},0xDF,0xDF,1,1},
		{{0x81,0x48,0x9F,0x0A,0x00},0xCB,0x9F,2,3},
		{{0x64,0xE0,0x01,0x0F},0xC0,0xE0,2,3},
		{{0x81,0x00,0x0F,0x02},0xEB,0xEB,2,2},
		{{0xFF,0xFF,0xFF,0x7F,0x0F,0x10},0xB1,0xB1,2,2},
		{{0x7F,0xB1,0x70,0x09},0xBF,0xB1,2,3},
		{{0xFF,0xFF,0xFF,0x7F,0x00,0x03},0x8F,0x8F,2,2},
		{{0x64,0xC0,0x02},0xDB,0xC0,1,2},
		{{0x00,0xB1,0x77,0x09},0x80,0xB1,2,3},
		{{0xC0,0x00,0xD1,0x00},0xB0,0xD1,1,2},
		{{0x40,0x80,0x0F,0x70},0xBB,0x80,2,3},
		{{0xC0,0x80,0x80,0x00,0x01},0xC0,0xC0,1,1},
		{{0x40,0x00},0xD0,0xD0,1,1},
		{{0xC0,0x80,0x80,0x00,0x70,0x77},0x9F,0x9F,2,2},
		{{0xFF,0xFF,0xFF,0x7F,0x9F,0x0F,0x70},0x7F,0x9F,2,3},
		{{0xFF,0xFF,0xFF,0x7F,0xB0,0x02,0x00},0x7F,0xB0,2,3},
		{{0x40,0x0A},0xCB,0xCB,1,1},
		{{0x81,0x80,0x80,0x00,0x00,0x09},0x9F,0x9F,2,2},
		{{0x40,0x03,0x01},0xBF,0xBF,2,2},
		{{0x00,0xEB,0x70,0x03},0x7F,0xEB,2,3},
		{{0x40,0x02,0x09},0x9F,0x9F,2,2},
		{{0x81,0x80,0x00,0x10,0x01},0xE0,0xE0,2,2},
		{{0xFF,0x7F,0xCF,0x03},0xBF,0xCF,1,2},
		{{0xC0,0x00,0x70},0xCB,0xCB,1,1},
		{{0x00,0x02,0x77},0xBB,0xBB,2,2},
		{{0x00,0x9F,0x70,0x0A},0xD0,0x9F,2,3},
		{{0xC0,0x80,0x00,0xDF,0x02},0xB0,0xDF,1,2},
		{{0xFF,0xFF,0x7F,0x91,0x0F,0x01},0x90,0x91,2,3},
		{{0xFF,0xFF,0xFF,0x7F,0x0A,0x77},0x8A,0x8A,2,2},
		{{0xFF,0xFF,0xFF,0x7F,0x02,0x00},0x8F,0x8F,2,2}
	};

	for (const auto& e : tests) {
		const unsigned char *pdt = &(e.data[0]);
		auto dt_size = e.data.size()-e.data_length;
		const unsigned char *pev = &(e.data[0+dt_size]);
		auto s_evstart = mtrk_event_get_midi_status_byte_unsafe(pev,e.rs);
		EXPECT_EQ(s_evstart,e.applic_status);
		auto s_dtstart = mtrk_event_get_midi_status_byte_dtstart_unsafe(pdt,e.rs);
		EXPECT_EQ(s_dtstart,e.applic_status);
		auto sz = mtrk_event_get_size_dtstart_unsafe(pdt,e.rs);
		EXPECT_EQ(sz,e.data.size());
	}
}
*/


