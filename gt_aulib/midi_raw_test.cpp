#include "gtest/gtest.h"
#include "..\au\midi_raw.h"
#include <vector>
#include <array>
#include <cstdint>


// Big-endian encoded multi-byte ints
TEST(midi_raw_tests, be2native) {
	struct i32_tests {
		std::array<unsigned char,4> field {0x00,0x00,0x00,0x00};
		int32_t ans {};
	};

	std::vector<i32_tests> i32_tests {
		{{0x00,0x00,0x00,0x00},0x00},
		{{0x40,0x00,0x00,0x00},0x40000000},
		{{0x00,0x00,0x00,0x40},0x00000040},
		{{0x7F,0x00,0x00,0x00},0x7F000000},
		{{0x00,0x00,0x00,0x7F},0x0000007F},

		{{0x71,0x00,0x00,0x00},0x71000000},
		{{0x70,0x00,0x00,0x00},0x70000000},
		{{0x0F,0x7F,0x00,0x00},0x0F7F0000},
		{{0x7F,0xFF,0x00,0x00},0x7FFF0000},

		{{0x71,0x80,0x00,0x00},0x71800000},
		{{0x00,0xC0,0x80,0x00},0x00C08000},
		{{0x3F,0xFF,0x7F,0x00},0x3FFF7F00},
		{{0x00,0x7F,0xFF,0x3F},0x007FFF3F},
	};
	for (const auto& e : i32_tests) {
		auto res = be_2_native<int32_t>(&(e.field[0]));
		EXPECT_EQ(res,e.ans) << "Failed for e.ans==" << e.ans << "\n";
	}

	struct ui64_tests {
		std::array<unsigned char,8> field {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
		uint64_t ans {};
	};
	std::vector<ui64_tests> ui64_tests {
		{{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},0x00},
		{{0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00},0x4000000000000000},
		{{0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00},0x0000004000000000},
		{{0x7F,0x00,0x00,0x00,0x00,0x00,0x00,0x00},0x7F00000000000000},
		{{0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00},0xFF00000000000000},
		{{0x00,0x00,0x00,0x7F,0x00,0x00,0x00,0x00},0x0000007F00000000},

		{{0x00,0x7F,0xFF,0x3F,0x00,0x00,0x00,0x00},0x007FFF3F00000000},
		{{0x00,0x00,0x00,0x00,0x00,0x7F,0xFF,0x3F},0x00000000007FFF3F},
	};
	for (const auto& e : ui64_tests) {
		auto res = be_2_native<uint64_t>(&(e.field[0]));
		EXPECT_EQ(res,e.ans) << "Failed for e.ans==" << e.ans << "\n";
	}

}


// All the examples from p.131 of the MIDI std.  
// Note that the 'field' array in the test struct is always 4 long; 
// midi_interpret_vl_field() has to be able to autodetect the end.  
TEST(midi_raw_tests, VLFieldSize) {

	std::vector<int32_t> onebyte_i32t {0x00,0x40,0x7F};
	for (const auto& e : onebyte_i32t) {
		auto res = midi_vl_field_size(e);
		EXPECT_EQ(res,1);
	}
	std::vector<int8_t> onebyte_i8t {0x00,0x40,0x7F};
	for (const auto& e : onebyte_i8t) {
		auto res = midi_vl_field_size(e);
		EXPECT_EQ(res,1);
	}

	std::vector<int32_t> twobyte_i32t {0x80,0x2000,0x3FFF};
	for (const auto& e : twobyte_i32t) {
		auto res = midi_vl_field_size(e);
		EXPECT_EQ(res,2);
	}

	std::vector<int32_t> threebyte_i32t {0x4000,0x100000,0x1FFFFF};
	for (const auto& e : threebyte_i32t) {
		auto res = midi_vl_field_size(e);
		EXPECT_EQ(res,3);
	}

	std::vector<int32_t> fourbyte_i32t {0x00200000,0x08000000,0x0FFFFFFF};
	for (const auto& e : fourbyte_i32t) {
		auto res = midi_vl_field_size(e);
		EXPECT_EQ(res,4);
	}
	std::vector<uint32_t> fourbyte_ui32t {0x00200000,0x08000000,0x0FFFFFFF};
	for (const auto& e : fourbyte_ui32t) {
		auto res = midi_vl_field_size(e);
		EXPECT_EQ(res,4);
	}
}

