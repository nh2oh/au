#include "gtest/gtest.h"
#include "..\aulib\input\midi\midi_raw.h"
#include "..\aulib\input\midi\mtrk_container_t.h"
#include <vector>
#include <cstdint>


// 
// "Small" (in the SBO-sense) midi_channel,meta,sysex_f0/f7 events from 
// the midi std and from files observed in the wild.  
//
// Tests of the mtrk_event_container_sbo_t(unsigned char *, int, unsigned char) ctor
//
TEST(mtrk_event_container_sbo_tests, assortedSMFEventTypesSmall) {
	struct test_ans_t {
		bool is_small {true};
		uint32_t delta_time {0};
		//smf_event_type type {smf_event_type::meta};
		uint32_t size {0};
		uint32_t data_size {0};
	};
	struct tests_t {
		std::vector<unsigned char> bytes {};
		test_ans_t ans {};
	};

	std::vector<tests_t> tests {
		// From p.142 of the midi std
		{{0x00,0xFF,0x58,0x04,0x04,0x02,0x18,0x08},  // meta, Time sig
		{true,0x00,8,7}},
		{{0x00,0xFF,0x51,0x03,0x07,0xA1,0x20},  // meta, Tempo
		{true,0x00,7,6}},
		{{0x00,0xFF,0x2F,0x00},  // meta, End of track
		{true,0x00,4,3}},

		// From p. 136 of the midi std:
		{{0x00,0xF0,0x03,0x43,0x12,0x00},  // sysex_f0
		{true,0x00,6,5}},
		{{0x81,0x48,0xF7,0x06,0x43,0x12,0x00,0x43,0x12,0x00},  // sysex_f7
		{true,200,10,8}},
		{{0x64,0xF7,0x04,0x43,0x12,0x00,0xF7},  // sysex_f7
		{true,100,7,6}},

		// From p. 141 of the midi std:
		{{0x00,0x92,0x48,0x96},  // Ch. 3 Note On #48, forte; dt=0
		{true,0x00,4,3}},
		{{0x81,0x48,0x82,0x48,0x64},  // Ch. 3 Note Off #48, standard; dt=200
		{true,200,5,3}},
	};

	for (const auto& e : tests) {
		mtrk_event_container_sbo_t c(e.bytes.data(),e.bytes.size(),0);
		//EXPECT_EQ(c.type(),e.ans.type);  // TODO:  Add test when vs fixes its enum class issues
		EXPECT_EQ(c.delta_time(),e.ans.delta_time);

		EXPECT_TRUE(c.is_small());
		EXPECT_FALSE(c.is_big());
		EXPECT_EQ(c.size(),e.ans.size);
		EXPECT_EQ(c.data_size(),e.ans.data_size);
		for (int i=0; i<e.ans.size; ++i) {
			EXPECT_EQ(c[i],e.bytes[i]);
			EXPECT_EQ(*(c.data()+i),e.bytes[i]);
		}
	}

}


// 
// "Small" (in the SBO-sense) meta events from the midi std and from files
// observed in the wild.  
//
// Tests of the mtrk_event_container_sbo_t(unsigned char *, int, unsigned char) ctor
//
TEST(mtrk_event_container_sbo_tests, metaEventsSmall) {
	struct test_ans_t {
		bool is_small {true};
		uint32_t delta_time {0};
		//smf_event_type type {smf_event_type::meta};
		uint32_t size {0};
		uint32_t data_size {0};
	};
	struct p142tests_t {
		std::vector<unsigned char> bytes {};
		test_ans_t ans {};
	};

	std::vector<p142tests_t> tests {
		//
		// From p.142 of the midi std
		//
		{{0x00,0xFF,0x58,0x04,0x04,0x02,0x18,0x08},  // Time sig
		{true,0x00,8,7}},

		{{0x00,0xFF,0x51,0x03,0x07,0xA1,0x20},  // Tempo
		{true,0x00,7,6}},

		{{0x00,0xFF,0x2F,0x00},  // End of track
		{true,0x00,4,3}},

		//
		// Not from the midi std:
		//
		{{0x00,0xFF,0x51,0x03,0x07,0xA1,0x20},  // Tempo (CLEMENTI.MID)
		{true,0x00,7,6}},

		// Padded w/ zeros, but otherwise identical to above
		{{0x00,0xFF,0x51,0x03,0x07,0xA1,0x20,0x00,0x00,0x00,0x00},  // Tempo (CLEMENTI.MID)
		{true,0x00,7,6}},

		{{0x00,0xFF,0x01,0x10,0x48,0x61,0x72,0x70,0x73,0x69,0x63,0x68,
		0x6F,0x72,0x64,0x20,0x48,0x69,0x67,0x68},  // Text element "Harpsichord High"
		{true,0x00,20,19}}
	};
	
	for (const auto& e : tests) {
		mtrk_event_container_sbo_t c(e.bytes.data(),e.bytes.size(),0);
		//EXPECT_EQ(c.type(),e.ans.type);
		EXPECT_EQ(c.type(),smf_event_type::meta);
		EXPECT_EQ(c.delta_time(),e.ans.delta_time);
		
		EXPECT_TRUE(c.is_small());
		EXPECT_FALSE(c.is_big());
		EXPECT_EQ(c.size(),e.ans.size);
		EXPECT_EQ(c.data_size(),e.ans.data_size);
		for (int i=0; i<e.ans.size; ++i) {
			EXPECT_EQ(c[i],e.bytes[i]);
			EXPECT_EQ(*(c.data()+i),e.bytes[i]);
		}
	}
	
}


TEST(mtrk_event_container_sbo_tests, metaEventsSmallCopyCtorAndCopyAssign) {
	std::vector<std::vector<unsigned char>> tests {
		//
		// From p.142 of the midi std
		//
		{{0x00,0xFF,0x58,0x04,0x04,0x02,0x18,0x08}},  // Time sig
		{{0x00,0xFF,0x51,0x03,0x07,0xA1,0x20}},  // Tempo
		{{0x00,0xFF,0x2F,0x00}},  // End of track
		//
		// Not from the midi std
		//
		{{0x00,0xFF,0x51,0x03,0x07,0xA1,0x20}},  // Tempo (CLEMENTI.MID)
		// Padded w/ zeros, but otherwise identical to above:
		{{0x00,0xFF,0x51,0x03,0x07,0xA1,0x20,0x00,0x00,0x00,0x00}},
		{{0x00,0xFF,0x01,0x10,0x48,0x61,0x72,0x70,0x73,0x69,0x63,0x68,
			0x6F,0x72,0x64,0x20,0x48,0x69,0x67,0x68}}   // Text element "Harpsichord High"
	};

	for (const auto& e : tests) {
		mtrk_event_container_sbo_t c1(e.data(),e.size(),0);
		
		//---------------------------------------------------------------------------
		// copy ctor:
		auto c2 = c1;

		//EXPECT_EQ(c2.type(),c1.type());
		EXPECT_EQ(c2.type(),c1.type());
		EXPECT_EQ(c2.delta_time(),c1.delta_time());

		EXPECT_TRUE(c2.is_small());
		EXPECT_FALSE(c2.is_big());
		EXPECT_EQ(c2.size(),c1.size());
		EXPECT_EQ(c2.data_size(),c1.data_size());
		for (int i=0; i<e.size(); ++i) {
			EXPECT_EQ(c2[i],e[i]);
			EXPECT_EQ(*(c2.data()+i),e[i]);
		}

		//---------------------------------------------------------------------------
		// copy assign:
		mtrk_event_container_sbo_t c3(tests[0].data(),tests[0].size(),0);
		c3 = c1;

		//EXPECT_EQ(c3.type(),c1.type());
		EXPECT_EQ(c3.type(),c1.type());
		EXPECT_EQ(c3.delta_time(),c1.delta_time());

		EXPECT_TRUE(c3.is_small());
		EXPECT_FALSE(c3.is_big());
		EXPECT_EQ(c3.size(),c1.size());
		EXPECT_EQ(c3.data_size(),c1.data_size());
		for (int i=0; i<e.size(); ++i) {
			EXPECT_EQ(c3[i],e[i]);
			EXPECT_EQ(*(c3.data()+i),e[i]);
		}
	}
}



// 
// "Big" (in the SBO-sense) meta events from the midi std and from files
// observed in the wild.  
//
// Tests of the mtrk_event_container_sbo_t(unsigned char *, int, unsigned char) ctor
//
TEST(mtrk_event_container_sbo_tests, metaEventsBig) {
	struct test_ans_t {
		bool is_small {true};
		uint32_t delta_time {0};
		//smf_event_type type {smf_event_type::meta};
		uint32_t size {0};
		uint32_t data_size {0};
	};
	struct tests_t {
		std::vector<unsigned char> bytes {};
		test_ans_t ans {};
	};

	std::vector<tests_t> tests {
		//
		// Not from the midi std:
		//
		{{0x00,0xFF,0x03,0x1D,0x48,0x61,0x6C,0x6C,0x65,0x6C,0x75,0x6A,
			0x61,0x68,0x21,0x20,0x4A,0x6F,0x79,0x20,0x74,0x6F,0x20,0x74,
			0x68,0x65,0x20,0x57,0x6F,0x72,0x6C,0x64,0x21},  // Sequence/track name (Hallelujah.mid)
		{false,0x00,33,32}},

		{{0x00,0xFF,0x01,0x7F,
			0x6D,0x6F,0x75,0x6E,0x74,0x20,0x6F,0x66,0x20,0x74,0x65,0x78,
			0x74,0x20,0x64,0x65,0x73,0x63,0x72,0x69,0x62,0x69,0x6E,0x67,
			0x20,0x61,0x6E,0x79,0x74,0x68,0x69,0x6E,0x67,0x2E,0x20,0x49,
			0x74,0x20,0x69,0x73,0x20,0x61,0x20,0x67,0x6F,0x6F,0x64,0x20,
			0x69,0x64,0x65,0x61,0x20,0x74,0x6F,0x20,0x70,0x75,0x74,0x20,
			0x61,0x20,0x74,0x65,0x78,0x74,0x20,0x65,0x76,0x65,0x6E,0x74,
			0x20,0x72,0x69,0x67,0x68,0x74,0x20,0x61,0x74,0x20,0x74,0x68,
			0x65,0x0D,0x0A,0x62,0x65,0x67,0x69,0x6E,0x6E,0x69,0x6E,0x67,
			0x20,0x6F,0x66,0x20,0x61,0x20,0x74,0x72,0x61,0x63,0x6B,0x2C,
			0x20,0x77,0x69,0x74,0x68,0x20,0x74,0x68,0x65,0x20,0x6E,0x61,
			0x6D,0x65,0x20,0x6F,0x66,0x20,0x74},  // Text event; 127 (0x7F) chars
		{false,0x00,131,130}},

		{{0x00,0xFF,0x01,0x5F,
			0x6D,0x6F,0x75,0x6E,0x74,0x20,0x6F,0x66,0x20,0x74,0x65,0x78,
			0x74,0x20,0x64,0x65,0x73,0x63,0x72,0x69,0x62,0x69,0x6E,0x67,
			0x20,0x61,0x6E,0x79,0x74,0x68,0x69,0x6E,0x67,0x2E,0x20,0x49,
			0x74,0x20,0x69,0x73,0x20,0x61,0x20,0x67,0x6F,0x6F,0x64,0x20,
			0x69,0x64,0x65,0x61,0x20,0x74,0x6F,0x20,0x70,0x75,0x74,0x20,
			0x61,0x20,0x74,0x65,0x78,0x74,0x20,0x65,0x76,0x65,0x6E,0x74,
			0x20,0x72,0x69,0x67,0x68,0x74,0x20,0x61,0x74,0x20,0x74,0x68,
			0x6D,0x65,0x20,0x6F,0x66,0x20,0x74,0x74,0x74,0x74,0x74},  // Text event; 95 (0x5F) chars
		{false,0x00,99,98}}
	};

	for (const auto& e : tests) {
		mtrk_event_container_sbo_t c(e.bytes.data(),e.bytes.size(),0);
		//EXPECT_EQ(c.type(),e.ans.type);
		EXPECT_EQ(c.type(),smf_event_type::meta);
		EXPECT_EQ(c.delta_time(),e.ans.delta_time);

		EXPECT_FALSE(c.is_small());
		EXPECT_TRUE(c.is_big());
		EXPECT_EQ(c.size(),e.ans.size);
		EXPECT_EQ(c.data_size(),e.ans.data_size);
		for (int i=0; i<e.ans.size; ++i) {
			EXPECT_EQ(c[i],e.bytes[i]);
			EXPECT_EQ(*(c.data()+i),e.bytes[i]);
		}
	}

}




// 
// "Big" (in the SBO-sense) meta events.  
//
// Tests copy ctoring and copy assigning one big container from/to another big
// container.  
//
TEST(mtrk_event_container_sbo_tests, metaEventsBigCopyCtorAndCopyAssign) {
	std::vector<std::vector<unsigned char>> tests {
		{0x00,0xFF,0x03,0x1D,  // 0x1D==29; Sequence/track name (Hallelujah.mid)
		0x48,0x61,0x6C,0x6C,0x65,0x6C,0x75,0x6A,
		0x61,0x68,0x21,0x20,0x4A,0x6F,0x79,0x20,0x74,0x6F,0x20,0x74,
		0x68,0x65,0x20,0x57,0x6F,0x72,0x6C,0x64,0x21},  

		{0x00,0xFF,0x01,0x7F,  // Text event; 127 (0x7F) chars
		0x6D,0x6F,0x75,0x6E,0x74,0x20,0x6F,0x66,0x20,0x74,0x65,0x78,
		0x74,0x20,0x64,0x65,0x73,0x63,0x72,0x69,0x62,0x69,0x6E,0x67,
		0x20,0x61,0x6E,0x79,0x74,0x68,0x69,0x6E,0x67,0x2E,0x20,0x49,
		0x74,0x20,0x69,0x73,0x20,0x61,0x20,0x67,0x6F,0x6F,0x64,0x20,
		0x69,0x64,0x65,0x61,0x20,0x74,0x6F,0x20,0x70,0x75,0x74,0x20,
		0x61,0x20,0x74,0x65,0x78,0x74,0x20,0x65,0x76,0x65,0x6E,0x74,
		0x20,0x72,0x69,0x67,0x68,0x74,0x20,0x61,0x74,0x20,0x74,0x68,
		0x65,0x0D,0x0A,0x62,0x65,0x67,0x69,0x6E,0x6E,0x69,0x6E,0x67,
		0x20,0x6F,0x66,0x20,0x61,0x20,0x74,0x72,0x61,0x63,0x6B,0x2C,
		0x20,0x77,0x69,0x74,0x68,0x20,0x74,0x68,0x65,0x20,0x6E,0x61,
		0x6D,0x65,0x20,0x6F,0x66,0x20,0x74},  

		{0x00,0xFF,0x01,0x5F,  // Text event; 95 (0x5F) chars
		0x6D,0x6F,0x75,0x6E,0x74,0x20,0x6F,0x66,0x20,0x74,0x65,0x78,
		0x74,0x20,0x64,0x65,0x73,0x63,0x72,0x69,0x62,0x69,0x6E,0x67,
		0x20,0x61,0x6E,0x79,0x74,0x68,0x69,0x6E,0x67,0x2E,0x20,0x49,
		0x74,0x20,0x69,0x73,0x20,0x61,0x20,0x67,0x6F,0x6F,0x64,0x20,
		0x69,0x64,0x65,0x61,0x20,0x74,0x6F,0x20,0x70,0x75,0x74,0x20,
		0x61,0x20,0x74,0x65,0x78,0x74,0x20,0x65,0x76,0x65,0x6E,0x74,
		0x20,0x72,0x69,0x67,0x68,0x74,0x20,0x61,0x74,0x20,0x74,0x68,
		0x6D,0x65,0x20,0x6F,0x66,0x20,0x74,0x74,0x74,0x74,0x74}  
	};
	
	bool first_iter=true;
	for (const auto& e : tests) {
		mtrk_event_container_sbo_t c1(e.data(),e.size(),0);

		//---------------------------------------------------------------------------
		// copy ctor:
		auto c2 = c1;

		EXPECT_EQ(c2.type(),c1.type());
		EXPECT_EQ(c2.delta_time(),c1.delta_time());

		EXPECT_FALSE(c2.is_small());
		EXPECT_TRUE(c2.is_big());
		EXPECT_EQ(c2.size(),c1.size());
		EXPECT_EQ(c2.data_size(),c1.data_size());
		for (int i=0; i<e.size(); ++i) {
			EXPECT_EQ(c2[i],e[i]);
			EXPECT_EQ(*(c2.data()+i),e[i]);
		}

		//---------------------------------------------------------------------------
		// copy assign:
		// c1 is created from tests[i]; create a c3 different from c1
		// then overwrite it with c1.  
		int j=1;
		if (!first_iter) {
			j=0;
		}
		mtrk_event_container_sbo_t c3(tests[j].data(),tests[j].size(),0);
		c3 = c1;

		EXPECT_EQ(c3.type(),c1.type());
		EXPECT_EQ(c3.delta_time(),c1.delta_time());

		EXPECT_FALSE(c3.is_small());
		EXPECT_TRUE(c3.is_big());
		EXPECT_EQ(c3.size(),c1.size());
		EXPECT_EQ(c3.data_size(),c1.data_size());
		for (int i=0; i<e.size(); ++i) {
			EXPECT_EQ(c3[i],e[i]);
			EXPECT_EQ(*(c3.data()+i),e[i]);
		}

		first_iter=false;
	}
}



