#include <vector>
#include <chrono>
#include <random>
#include <optional>
#include <numeric>
#include "rand_rp.h"
#include "types\rp_t.h"
#include "util\au_util_all.h"

// rand_rp() ~ rdur()
// The rp returned will always span an integer number of bars since the
// algorithm appends random 1-bar "segments" to a growing rp.  
std::optional<std::vector<note_value>> rand_rp(ts_t ts_in, std::vector<note_value> dp_in, \
	std::vector<double> pd_in, int nnts_in, bar_t nbr_in, rand_rp_opts opts) {
	// Timeout settings
	std::chrono::seconds maxt {3000};
	//auto tfail {std::chrono::system_clock::now()+opts.maxt};
	auto tfail {std::chrono::system_clock::now()+maxt};

	int mode {0};
	if (nnts_in == 0 && nbr_in >= bar_t{1}) {  // fixed nbr, unconstrained nnts
		mode = 1;
	} else if (nnts_in >= 1 && nbr_in == bar_t{0}) { // fixed nnts, unconstrained nbr
		mode = 2;
	} else if (nnts_in >= 1 && nbr_in >= bar_t{1}) { // nnts, nbr both constrained
		mode = 3;
	}

	std::vector<note_value> rpseg {};  // "rp segment" always == 1 bar exactly
	std::vector<note_value> rp {};
	bool f_success {false}; // flag success
	std::default_random_engine randeng {};
	randeng.seed(std::chrono::system_clock::now().time_since_epoch().count());
	std::uniform_int_distribution<int> rdist {0,static_cast<int>(dp_in.size()-1)};
	bar_t nbar_rp {0};  // counter
	while (std::chrono::system_clock::now() < tfail) {
		// Each iteration appends rpseg (generated by the inner loop) to rp.  rpseg
		// always spans exactly 1 bar.  

		note_value rpseg_tot_notev {0};  // holds the sum of the growing rpseg
		while (std::chrono::system_clock::now() < tfail) {
			// Adds one duration element at a time to rpseg until rpseg is exactly 
			// 1 bar long.  If rpseg overshoots, rpseg is cleared and the process
			// continues.  The loop exits when rpseg == 1 bar or if it times out.  
			// ts_in.bar_unit() is the note_value that exactly spans 1 bar.  Summing
			// the random note_value elements and comparing to ts_in.bar_unit() is 
			// faster than running calculating nbar() each time.  
			auto ridx {rdist(randeng)};
			note_value rp_e {dp_in[ridx]};  // "rp element"
			rpseg.push_back(rp_e);
			rpseg_tot_notev += rp_e;

			if (rpseg_tot_notev < ts_in.bar_unit()) {
				//...
			} else if (rpseg_tot_notev > ts_in.bar_unit()) {
				rpseg.clear();
				rpseg_tot_notev = note_value {0};
			} else if (rpseg_tot_notev == ts_in.bar_unit()) {
				break;
			}
		}

		// At this point, rpseg is exactly 1 bar in length (modes 1,3), or 
		// exactly nnts_in _notes_ in length (mode 2).  
		rp.insert(rp.end(),rpseg.begin(),rpseg.end());
		rpseg.clear();
		nbar_rp+=bar_t{1};  // rpseg is always exactly 1 bar

		if (mode == 1) { // Fixed nbars, floating nnotes
			if (nbar_rp == nbr_in) {
				// Success
				f_success = true;
				break;
			}
			// There is no overshooting in mode 1, since in mode 1 the inner loop
			// always adds exactly 1 bar
		} else if (mode == 2) {  // Fixed nnts, floating nbars
			if (rp.size() == nnts_in) {
				// Success
				f_success = true;
				break;
			} else if (rp.size() > nnts_in) {
				// Overshot
				rp.clear();	nbar_rp = bar_t{0};
			} else if (rp.size() < nnts_in) {
				// Not overshot, but not done yet
			}
		} else if (mode == 3) { // Fixed nbars, fixed nnotes
			if (nbar_rp == nbr_in && rp.size() == nnts_in) {
				// Success
				f_success = true;
				break;
			} else if (nbar_rp > nbr_in || rp.size() > nnts_in) {
				// Overshot
				rp.clear();	nbar_rp = bar_t{0};
			} else {
				// Not overshot, but not done yet
			}
		}
	} // Build next 1-bar segment rpseg

	if (f_success) {
		return std::optional<std::vector<note_value>> {rp};
	}

	return {};
}

std::optional<std::vector<note_value>> rand_rp(ts_t ts_in, std::vector<note_value> dp_in, \
	std::vector<double> pd_in, int nnts_in, bar_t nbr_in) {
	rand_rp_opts opts {std::chrono::seconds {3}};
	return rand_rp(ts_in, dp_in, pd_in, nnts_in, nbr_in, opts);
}

