#pragma once
#include "..\util\au_frac.h"
#include <string>
#include <vector>


enum class common_duration_t {
	// The final digit is the number of dots, the leading digits are the
	// exponent of the base-value (m).  
	ow = 8, owd = 81, owdd = 82, owddd = 83,
	qw = 20, qwd = 21, qwdd = 22, qwddd = 23,
	dw = 10, dwd = 11, dwdd = 12, dwddd = 13,
	w = 00, wd = 01, wdd = 02, wddd = 03,
	h = -10, hd = -11, hdd = -12, hddd = -13,
	q = -20, qd = -21, qdd = -22, qddd = -23,
	e = -30, ed = -31, edd = -32, eddd = -33,
	sx = -40, sxd = -41, sxdd = -42, sxddd = -43,
	t = -50, td = -51, tdd = -52, tddd = -53,
	sf = -60, sfd = -61, dfdd = -62, sfddd = -63,
	ote = -70, oted = -71, otedd = -72, oteddd = -73,
	tfs = -80, tfsd = -81, tfsdd = -82, tfsddd = -83,
	ftw = -90, ftwd = -91, ftwdd = -92, ftwddd = -93,
	ttwf = -100, ttwfd = -101, ttwfdd = -102, ttwfddd = -103, 
	twfe = -110, twfed = -111, twfedd = -112, twfeddd = -113,
	fnsx = -120, fnsxd = -121, fnsxdd = -122, fnsxddd = -123
};

using d = common_duration_t;

//
// Implements duration math
// The "public interface" to a d_t is an nv_t, which implements calculations
// for number of dots, "base duration type" ("quarter," "half," etc), methods
// for adding/removing dots, useful splitting methods, etc.  
//
// A singlet nv_t has a duration d = (1/(2^m))*(2-1/(2^n)) where m is an 
// integer on (-infty,infty) and n is an integer on [0,infty).  I call 
// this representation "m,n form."  Not all sums (and differences) of
// singlet nv_t's can be represented in m,n form.  That is, some sets
// of singlet nv_t's span a duration for which no singlet nv_t can
// exists.  For example, 3 qd's:
// (1/4). + (1/4). + (1/4). = (1/4 + 1/8) + (1/4 + 1/8) + (1/4 + 1/8)
//                          = (1/2 + 1/4) + (1/4 + 1/8)
//                          = (1/2).. + (1/4)
//                          = (1/2). + (1/4).
//                          = (1/1) + (1/8)
// (Several duplet representations, but no singlet exists.)
//
// "a,b form" is an alternative, more general representation of a duration 
// spanned by any number of any type of nv_t's.  Any duration d that can
// be represented an m,n-form nv_t _or_ as a sum of nv_t's can be 
// represented as d = a/(2^b) where a is an integer on [1,infty) and b is an
// integer on (-infty,infty).  This follows as a consequence of the definition
// of m,n-form above.  
//
// TODO:  Actually i am allowing 0 and (-) durations => a ~ integer on 
// (-infty,infty)
//
// For an arbitrary a,b-form duration d, an equivalent m,n-form 
// representation (and therefore an equivavalent singlet nv_t) exists iff
// a is a Mersenne number.  That is, a must belong to the set 
// {1,3,7,15,31,63,127,..., 2^(N+1)-1, ... infty}.  
// This is the seq generated by sum(2^i,i=0,N) for all integer N >=0.  
//
// If a is a Mersenne number, then the a,b and m,n-form representations are
// related by:
// a = 2^(n+1) - 1  <=>  n = log2(a+1) - 1
// b = n + m        <=>  m = b - log2(a+1) + 1
//
//
// To sum a pair of nv_t's it is easiest to first convert their m,n 
// representation to the equivalent a,b form.  
// For any pair of durations d1 = a1/2^b1, d2 = a2/2^b2, and b2 >= b1, their 
// sum d3 = d1 + d2 = a3/2^b3 with
// a3 = a1*(2^(b2-b1)) + a2
// b3 = b2
// or alternatively (and equivalently)
// a3 = a1 + a2/(2^(b2-b1))
// b3 = b1
// 
// Note the condition that the pair d1, d2 be numbered so that b2 >= b1.  
// This ensures a3 is an integer, which is a requirement of a,b-form.  
//
class d_t {
public:
	struct mn {
		int m {0};
		int n {0};
	};
	d_t()=default;
	explicit d_t(common_duration_t);
	explicit d_t(const mn&);

	bool singlet_exists() const;
	std::vector<d_t> to_singlets() const;
		// Add options to set which types of tuplets are returned

	int ndot() const;
		// If the object has no singlet representation, ndot == 0, even if
		// there is a tuplet representation where one or more or all the
		// members have dots (even if they have the same number of dots).
	int base() const;
		// The d_t w/ the same value of m_m
		// If the object has no singlet representation, returns 0
	std::string print() const;

	bool set_base(int const&);
	bool set_dots(int const&);
	bool add_dots(int const& =1);
	bool rm_dots(int const&);
	bool rm_dots();  // Remove all the dots, if any

	d_t& operator+=(const d_t&);
	d_t& operator-=(const d_t&);
	d_t& operator*=(const int&);
	// d_t& operator/=(const int&);
	bool operator<(const d_t&) const;
	bool operator>(const d_t&) const;
	bool operator==(const d_t&) const;
private:
	struct ab {
		int a {0};
		int b {0};
	};

	int m_a {0};
	int m_b {0};
	static const int max_nplet;
		// Possibly a better way to do this is to specify a maximum
		// "resolution" in terms of a,b and/or m,n

	d_t::ab mn2ab(const d_t::mn&) const;
	d_t::mn ab2mn(const d_t::ab&) const;
		// Assumes the m,n-form exists
};

bool operator<=(const d_t&, const d_t&);
bool operator>=(const d_t&, const d_t&);
bool operator!=(const d_t&, const d_t&);
d_t operator-(d_t, const d_t&);
d_t operator+(d_t, const d_t&);
//double operator/(const d_t&, const d_t&);
d_t operator/(const d_t&, const int&);
d_t operator*(const int&, const d_t&);
d_t operator*(const d_t&, const int&);




/*
//
// A duration that represents a note value.  
// Although singlet nv_t's have an m,n-form, nv_t's need not be singlets;
// it is perfectly acceptable for an nv_t to have to be represented as a
// tuplet.  
//
//


class nv_t {
public:
	nv_t() = default;
		// Creates a whole-note:  bv == 1, ndots == 0
	nv_t(common_duration_t);
	explicit nv_t(int m, int n);

	std::string print() const;





	friend double operator/(nv_t const&, nv_t const&);
		// Division is needed to get the nv without breaking encapsulation.  
		// The nv() can be extracted from an nv_t by dividing the nv_t by
		// a whole note, the "unit nv_t" nv_t {1,0}.  A whole note may also
		// be obtained by calling the constructor with no arguments, ie,
		// nv_t() == nv_t {1,0} == a whole note.  
	friend bool operator==(nv_t const&, nv_t const&);
	friend bool operator!=(nv_t const&, nv_t const&);
	friend bool operator<(nv_t const&, nv_t const&);
	friend bool operator>(nv_t const&, nv_t const&);
	friend bool operator<=(nv_t const&, nv_t const&);
	friend bool operator>=(nv_t const&, nv_t const&);

	static const double max_bv;
	static const double min_bv;
	static const int max_ndots;
private:


	d_t mn2d(const nv_t::mn&) const;
	d_t m_d {common_duration_t::w};

	double nv() const;  // == (1/(2^m))*(2-1/(2^n))
	double bv() const;  // == 1/(2^m)

	static const int min_bv_exponent;
	static const int max_bv_exponent;
};



class tie_t {
public:
	tie_t()=default;
	explicit tie_t(nv_t const&);
	explicit tie_t(int const&, nv_t const&);
	explicit tie_t(nv_t const&, nv_t const&);
	explicit tie_t(std::vector<nv_t> const&);

private:
};


*/
