#pragma once
//#include "..\util\au_frac.h"
#include <string>
#include <vector>


enum class common_duration_t {
	// The final digit is the number of dots, the leading digits are the
	// exponent of the base-value (m).  
	ow = 30, owd = 31, owdd = 32, owddd = 33,
	qw = 20, qwd = 21, qwdd = 22, qwddd = 23,
	dw = 10, dwd = 11, dwdd = 12, dwddd = 13,
	w = 00, wd = 01, wdd = 02, wddd = 03,
	h = -10, hd = -11, hdd = -12, hddd = -13,
	q = -20, qd = -21, qdd = -22, qddd = -23,
	e = -30, ed = -31, edd = -32, eddd = -33,
	sx = -40, sxd = -41, sxdd = -42, sxddd = -43,
	t = -50, td = -51, tdd = -52, tddd = -53,
	sf = -60, sfd = -61, dfdd = -62, sfddd = -63,
	ote = -70, oted = -71, otedd = -72, oteddd = -73,  //  1/128
	tfs = -80, tfsd = -81, tfsdd = -82, tfsddd = -83,  //  1/256
	ftw = -90, ftwd = -91, ftwdd = -92, ftwddd = -93,  //  1/512
	ttwf = -100, ttwfd = -101, ttwfdd = -102, ttwfddd = -103,   //  1/1024
	twfe = -110, twfed = -111, twfedd = -112, twfeddd = -113,  //  1/2048
	fnsx = -120, fnsxd = -121, fnsxdd = -122, fnsxddd = -123,  //  1/4096
	z = -9999  // Note the special value for a zero-duration note
};
using d = common_duration_t;



//
// Implements duration math
// The "public interface" to a d_t is an nv_t, which implements calculations
// for number of dots, "base duration type" ("quarter," "half," etc), methods
// for adding/removing dots, useful splitting methods, etc.  
//
// A singlet nv_t has a duration d = (1/(2^m))*(2-1/(2^n)) where m is an 
// integer on (-infty,infty) and n is an integer on [0,infty).  I call 
// this representation "m,n form."  It follows that there are no nv_t's with
// duration <= 0.  Not all sums (or differences, even if we restrict ourselves
// to positive differences) of singlet nv_t's can be represented in m,n form.  
// That is, some sets of singlet nv_t's span a duration for which no singlet nv_t 
// can exist, and some durations (even positive durations) can not be represented
// by a singlet nv_t.  For example, 3 qd's:
// (1/4). + (1/4). + (1/4). = (1/4 + 1/8) + (1/4 + 1/8) + (1/4 + 1/8)
//                          = (1/2 + 1/4) + (1/4 + 1/8)
//                          = (1/2).. + (1/4)
//                          = (1/2). + (1/4).
//                          = (1/1) + (1/8)
// (There are several duplet representations, but no singlet.)
//
// "a,b form" is an alternative, more general representation of a duration 
// spanned by any number of any type of nv_t's.  Any duration d that can
// be represented an m,n-form nv_t _or_ as a sum (or difference) of nv_t's can be 
// represented as d = a/(2^b) where a is an integer on (-infty,infty) and b is an
// integer on (-infty,infty).  This follows as a consequence of the definition
// of m,n-form above.  
//
// For an arbitrary a,b-form duration d, an equivalent m,n-form 
// representation (and therefore an equivavalent singlet nv_t) exists iff
// a is a Mersenne number.  That is, a must belong to the set 
// {1,3,7,15,31,63,127,..., 2^(N+1)-1, ... infty}.  
// This is the seq generated by sum(2^i,i=0,N) for all integer N >=0.  
// Any number that can be written as 2^n - 1 is a Mersenne number (if n is
// prime, the number is a "Mersenne prime").  Note that a <= 0 is not a mersenne
// number, and therefore an a,b-form duration with a <= 0 does not correspond
// to a singlet nv_t, which is consistent with the constraint noted above that
// that all nv_t's have duration > 0.  
//
// If a is a Mersenne number, then the a,b and m,n-form representations are
// related by:
// a = 2^(n+1) - 1  <=>  n = log2(a+1) - 1
// b = n + m        <=>  m = b - log2(a+1) + 1
//
//
// To sum a pair of nv_t's it is easiest to first convert the m,n representation
// of each to the equivalent a,b form.  
// For any pair of durations d1 = a1/2^b1, d2 = a2/2^b2, and b2 >= b1, their 
// sum d3 = d1 + d2 = a3/2^b3 with
// a3 = a1*(2^(b2-b1)) + a2
// b3 = b2
// or alternatively (and equivalently)
// a3 = a1 + a2/(2^(b2-b1))
// b3 = b1
// 
// Note the condition that the pair d1, d2 be ordered so that b2 >= b1.  
// This ensures a3 is an integer, which is a requirement of a,b-form.  
//
class d_t {
public:
	struct mn {
		// Exposed to the world because the representation of a note duration in the
		// form d = (1/(2^m))*(2-1/(2^n)) is widely known and expected.  
		int m {0};
		int n {0};
	};
	d_t()=default;
	d_t(common_duration_t);
	explicit d_t(const mn&);
	explicit d_t(double);  // A duration spanning an amount of time == this many whole notes.

	bool singlet_exists() const;
	std::vector<d_t> to_singlets() const;
		// Unconstrained
	std::vector<d_t> to_singlets_partition(const d_t&) const;
		// The first n entries must exactly == the arg
	std::vector<d_t> to_singlets_partition_max(const d_t&, const d_t&) const;
		// The first n entries must exactly == arg1; entries [n+1,end) must be
		// divisible into s s_i-element subsequences m->m+s_i each exactly == 
		// arg2, except the final subsequence, which may be <= arg2.

	bool weird() const;

	int ndot() const;
		// If the object has no singlet representation, ndot == 0, even if
		// there is a tuplet representation where one or more or all the
		// members have dots (even if they have the same number of dots).
	int base() const;
		// The m exponent of the d_t
		// If the object has no singlet representation, returns 0
	d_t base_nv() const;
		// The value of the present object with n set to 0
		// If the object has no singlet representation returns the present object.  

	struct opts {
		bool denom_only {false};  // TODO:  What does this do??
	};
	std::string print(d_t::opts={}) const;

	bool set_base(int);
	bool set_dots(int);
	bool add_dots(int=1);
	bool rm_dots(int);
	bool rm_dots();  // Remove all the dots, if any

	d_t& operator+=(const d_t&);
	d_t& operator-=(const d_t&);
	d_t& operator*=(const double&);
	d_t& operator/=(const double&);
	friend double operator/(const d_t&, const d_t&);  // TODO:  Why friend?
	bool operator<(const d_t&) const;
	bool operator>(const d_t&) const;
	bool operator==(const d_t&) const;

	friend d_t gcd(const d_t, const d_t);
private:
	/*class ab {
		// TODO:  Am i going overboard w/ this embedded class dfn?
		// a,b-form:  a/(2^b)
		// a,b are stored such that the fraction a/(2^b) is in reduced form.  
	public:
		ab()=default;
		explicit ab(int,int);
		explicit ab(const d_t::mn&);

		ab operator+(const ab&) const;
		ab operator-(const ab&) const;
		double val() const;
		bool singlet_exists() const;
		d_t::mn to_mn() const;  // Assumes the m,n-form exists; check first!
		int get_a() const;
		int get_b() const;
	private:
		int a {0};
		int b {0};
		void reduce();
	};

	ab m_ab {0,0};*/

	int a_ {0};
	int b_ {0};
	void reduce();
	double num_whole_nts() const;
	d_t::mn to_mn() const;
	bool mn_exists() const;

	static const int max_nplet;
	static const double min_duration;

	//ab dbl2ab(double) const;
		// This is implemented here and not as a constructor of class ab because
		// it reads min_duration.  I could make it an ab constructor with the addnl
		// min-duration argument.  
};

bool operator<=(const d_t&, const d_t&);
bool operator>=(const d_t&, const d_t&);
bool operator!=(const d_t&, const d_t&);
d_t operator-(d_t, const d_t&);
d_t operator+(d_t, const d_t&);
d_t operator*(const double&, d_t);
d_t operator*(d_t, const double&);
d_t operator/(d_t, const double&);


//
// If !dt_str_parsed.is_valid, all other fields have whatever they were default-constructed
// with... they should be regarded as "undefined."  
//
struct dt_str_parsed {
	bool is_valid {false};
	int denom {0};
	int ndot {0};
};
dt_str_parsed parse_dt_string(const std::string&);



namespace autests {
// min m, min n, max m, max n
// Note that min m corresponds to the longest duration
struct dtset {
	d_t dt {};
	int m {0};
	int n {0};
};
std::vector<dtset> make_dt_set(int, int, int, int);
}



/*
class nv_t {
public:
	struct mn {
		// Exposed to the world because the representation of a note duration in the
		// form d = (1/(2^m))*(2-1/(2^n)) is widely known and expected.  
		int m {0};
		int n {0};
	};
	nv_t()=default;  // quarter-note
	nv_t(common_duration_t);
	explicit nv_t(const nv_t::mn&);
	explicit nv_t(double);  // A duration spanning this many whole notes.
	explicit nv_t(const d_t&);  // std::abort() if no m,n-form exists
private:
	nv_t::mn mn_ {2,0};  // quarter-note
};
*/










