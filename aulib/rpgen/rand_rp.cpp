#include "rand_rp.h"
#include "..\types\nv_t.h"
#include "..\types\ts_t.h"
#include "..\types\beat_bar_t.h"
#include "..\types\rp_t.h"
#include "..\util\au_random.h"
#include "..\util\au_algs.h"
#include <vector>
#include <chrono>
#include <random>
#include <exception>

//
// rand_rp()
// Generates an rp that will always span an integer number of bars.  The algorithm appends randomly
// generated 1-bar "segments" to a growing rp.  Corresponds to rdur() of the Matlab implementation.  
//
// TODO:  Ignores pd_in
// TODO:  Will not work for fractional nbars
// TODO: Bug:  {0,1} fails since rpseg must always be exactly == 1 bar
//       See unit test UnconstrainedNbarsConstrainedNnts
//
randrp_result rand_rp(const randrp_input& p) {
	if (p.nbars < 0_br || p.nnts < 0 || (p.nbars == 0_br && p.nnts == 0)
		|| p.nvset.size() != p.pd.size()) {
		std::abort();
	}

	int mode {0};
	if (p.nnts == 0 && p.nbars >= 1_br) {  // fixed nbr, unconstrained nnts
		mode = 1;
	} else if (p.nnts >= 1 && p.nbars == 0_br) { // fixed nnts, unconstrained nbr
		mode = 2;
	} else if (p.nnts >= 1 && p.nbars >= 1_br) { // nnts, nbr both constrained
		mode = 3;
	}

	std::vector<d_t> rpseg {};  // "rp segment" always == 1 bar exactly
	std::vector<d_t> rp {};  rp.reserve(p.nnts);  // The full rp
	randrp_result result {}; result.success = false;

	auto randeng = new_randeng(true);
	std::uniform_int_distribution<int> rdist {0,static_cast<int>(p.nvset.size()-1)};
	
	bar_t nbar_rp {0};  // counter
	const auto tfail {std::chrono::system_clock::now()+p.maxt};
	while ((std::chrono::system_clock::now() < tfail) && !result.success) {
		// Each iteration of the outer loop appends rpseg (exactly == 1 bar, generated by the 
		// inner loop) to rp.

		bar_t rpseg_nbar {0.0};  // the # of bars spanned by the growing rpseg
		while (std::chrono::system_clock::now() < tfail) {
			// Adds one duration element at a time to rpseg until rpseg is exactly  1 bar long.  
			// If rpseg overshoots, rpseg is cleared and the process continues.  The loop exits 
			// when rpseg == 1 bar or if it times out.  
			//
			d_t rp_e = p.nvset[rdist(randeng)];  // "rp element"
			rpseg.push_back(rp_e);
			rpseg_nbar += nbar(p.ts,rp_e);

			if (rpseg_nbar < 1_br) {
				//...
			} else if (rpseg_nbar > 1_br) {
				rpseg.clear();
				rpseg_nbar = 0_br;
			} else if (rpseg_nbar == 1_br) {
				break;
			}
		}

		// At this point, rpseg is exactly 1 bar in length (unless the inner loop exited
		// due to timeout).
		rp.insert(rp.end(),rpseg.begin(),rpseg.end());
		rpseg.clear();
		nbar_rp += rpseg_nbar; //1_br;  // rpseg is always exactly 1 bar

		if (mode == 1) {  // Fixed nbars, floating nnotes
			if (nbar_rp == p.nbars) { // Success
				result.success = true;
			}
			// There is no overshooting in mode 1, since in the inner loop
			// always produces an rpseg of exactly 1 bar
		} else if (mode == 2) {  // Fixed nnts, floating nbars
			if (rp.size() == p.nnts) { // Success
				result.success = true;
			} else if (rp.size() > p.nnts) {  // Overshot
				rp.clear();	nbar_rp = 0_br;
			} else if (rp.size() < p.nnts) {
				// Not overshot, but not done yet
			}
		} else if (mode == 3) {  // Fixed nbars, fixed nnotes
			if (nbar_rp == p.nbars && rp.size() == p.nnts) {  // Success
				result.success = true;
			} else if (nbar_rp > p.nbars || rp.size() > p.nnts) {  // Overshot
				rp.clear();	nbar_rp = 0_br;
			} else {
				// Not overshot, but not done yet
			}
		}
	}  // Build next 1-bar segment rpseg


	if (result.success) {
		result.rp = rp_t {p.ts,rp};
	}  // if !result.success, result.rp is a default-constructed rp_t
	return result;
}

randrp_result rand_rp(ts_t ts, std::vector<d_t> nvset,
	std::vector<double> pd, int nnts, bar_t nbars, std::chrono::seconds maxt) {
	randrp_input input {};
	input.ts = ts; input.nvset = nvset; input.pd = pd;
	input.nnts = nnts; input.nbars = nbars; input.maxt = maxt;
	return rand_rp(input);
}

rrpinput_validator_result validate_randrp_input(const randrp_input& rrp_inp) {
	rrpinput_validator_result result {};

	if (rrp_inp.nvset.size() == 0) {
		result.nvset_is_valid = false;
		result.msg += "Must supply at least one nv.\n";
	} else {
		if (n_unique_nosort(rrp_inp.nvset) == rrp_inp.nvset.size()) {
			result.nvset_is_valid = true;
		} else {
			result.nvset_is_valid = false;
			result.msg += "All elements of nvset must be unique.\n";
		}
	}

	// TODO:  Elements of pd_in should be > 0
	if (rrp_inp.pd.size() == 0 || (rrp_inp.pd.size() > 0 && rrp_inp.pd.size()==rrp_inp.nvset.size())) {
		result.pd_is_valid = true;
	} else { // otherwise, pd_is_valid == false
		result.pd_is_valid = false;
		result.msg += "pd.size() == 0 or pd.size == nvset.size().  \n";
	}

	if (rrp_inp.nnts < 0) {
		result.nnts_is_valid = false;
		result.msg += "nnts must be >= 0.\n";
	}
	if (rrp_inp.nbars < 0_br) {
		result.nbars_is_valid = false;
		result.msg += "nbars must be >= 0.\n";
	}
	if (rrp_inp.nnts == 0 && rrp_inp.nbars == 0_br) {
		result.nnts_is_valid = false;
		result.nbars_is_valid = false;
		result.msg += "One of nnts, nbars > 0.\n";
	}
	if (rrp_inp.maxt < std::chrono::seconds {0}) {
		result.maxt_is_valid = false;
		result.msg += "maxt must be >= 0 seconds.\n";
	}

	result.input_is_valid = result.maxt_is_valid && result.nbars_is_valid && result.nnts_is_valid 
		&& result.nvset_is_valid && result.pd_is_valid;
	
	return result;
}

/*
au::uih_parser_result<randrp_input> 
	parse_randrp_input::operator()(randrp_input const& randrp_input_in) const {
	au::uih_parser_result<randrp_input> result {{},""};
		// NB: Clearing the default failmsg
	bool input_is_valid = true;
	if (randrp_input_in.nvset.size() < 1) {
		input_is_valid = false;
		result.failmsg += "Must supply at least one nv.\n";
	}
	if (randrp_input_in.nvset.size() != randrp_input_in.pd.size()) {
		input_is_valid = false;
		result.failmsg += "Must supply a relative probability for each nv.\n";
	}
	// TODO:  At least 2 elements of pd_in should be > 0
	if (randrp_input_in.n_nts < 0) {
		input_is_valid = false;
		result.failmsg += "n_nts must be >= 0.\n";
	}
	if (randrp_input_in.n_nts == 0 && randrp_input_in.n_bars == bar_t{0}) {
		input_is_valid = false;
		result.failmsg += "One of n_nts, n_bars must be constrained.\n";
	}

	if (input_is_valid) { result.o_result = randrp_input_in;}
	return result;
}
*/

